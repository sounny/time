<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="light dark" />
  <title>Time</title>
  <style>
    /* ---------- Base ---------- */
    :root{
      --bg:#0b0c10; --fg:#e9e9ef; --muted:#a7a7b3; --card:#15161d; --border:#242633; --accent:#6ea8fe;
      --shadow: 0 1px 2px rgba(0,0,0,.15), 0 8px 24px rgba(0,0,0,.18);
    }
    @media (prefers-color-scheme: light){
      :root{ --bg:#f7f7fb; --fg:#14151a; --muted:#55586a; --card:#ffffff; --border:#e8e9ee; --accent:#2b59ff; --shadow: 0 1px 2px rgba(0,0,0,.06), 0 8px 24px rgba(0,0,0,.08); }
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0; background:var(--bg); color:var(--fg);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans", Ubuntu, Cantarell, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
      -webkit-font-smoothing:antialiased; line-height:1.35;
    }
    .container{ max-width: 1100px; margin: 0 auto; padding: 20px; }

    /* ---------- Header / Controls ---------- */
    header{
      display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom: 12px;
    }
    h1{ font-size: clamp(22px, 2.4vw, 28px); margin:0; letter-spacing:.2px; }
    .controls{ display:flex; gap:8px; flex-wrap:wrap; }
    .sort-controls{ justify-content:flex-start; margin: 0 0 10px; }
    button, .btn{
      appearance:none; border:1px solid var(--border); background:var(--card); color:var(--fg);
      padding:8px 10px; border-radius:9px; cursor:pointer; font-weight:600; box-shadow: var(--shadow);
    }
    button:hover{ border-color:var(--accent); }
    button:focus-visible{ outline:2px solid var(--accent); outline-offset:2px; }

    /* ---------- Hero Clock ---------- */
    .hero{
      border:1px solid var(--border); background:var(--card); border-radius:14px; padding:22px; box-shadow: var(--shadow);
      display:grid; gap:10px; justify-items:center; margin-bottom: 18px;
    }
    .hero-label{ font-size:14px; color:var(--muted); }
    .bigtime{
      font-size: clamp(40px, 9vw, 96px);
      line-height:1; font-weight:800; letter-spacing: .02em;
      font-variant-numeric: tabular-nums;
      text-align:center;
    }
    .meta{ color:var(--muted); font-size: 14px; display:flex; gap:10px; flex-wrap:wrap; justify-content:center; }
    .badge{
      display:inline-flex; align-items:center; gap:6px;
      padding:4px 8px; border-radius:999px; border:1px solid var(--border); background:transparent; color:var(--fg);
      font-size:12px; font-weight:600;
    }
    .countdown{ font-size:13px; color:var(--muted); }

    /* ---------- Map ---------- */
    .map-card{
      border:1px solid var(--border); background:var(--card); border-radius:14px; box-shadow: var(--shadow);
      padding:16px; display:grid; gap:10px; margin: 0 0 18px; overflow:hidden;
    }
    .map-head{ display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; }
    .map-title{ margin:0; font-size:18px; }
    .map-status{ color:var(--muted); font-size:14px; margin:0; }
    .map-frame{
      width:100%; max-height:360px; border-radius:12px; border:1px solid var(--border);
      object-fit:cover; background: repeating-linear-gradient(45deg, var(--card), var(--card) 10px, var(--border) 10px, var(--border) 20px);
      min-height: 220px;
    }
    .map-empty{ display:flex; align-items:center; justify-content:center; color:var(--muted); font-size:14px; }

    /* ---------- Add City ---------- */
    .adder{
      display:flex; gap:8px; align-items:center; justify-content:center; flex-wrap:wrap; margin: 6px 0 14px;
    }
    input[type="text"]{
      background:var(--card); color:var(--fg); border:1px solid var(--border);
      padding:9px 10px; border-radius:9px; min-width:260px;
    }
    input::placeholder{ color:var(--muted); }
    input:focus-visible{ outline:2px solid var(--accent); outline-offset:2px; }

    /* ---------- Grid ---------- */
    .grid{
      display:grid; gap:12px;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }
    .card{
      border:1px solid var(--border); background:var(--card); border-radius:12px; padding:12px 12px 14px; box-shadow: var(--shadow);
      display:grid; gap:6px;
    }
    .card.dragging{ opacity:.75; border-style:dashed; }
    .card header{ display:flex; align-items:center; justify-content:space-between; gap: 8px; }
    .title{ font-size:16px; margin:0; }
    .smalltime{ font-size:28px; font-weight:700; letter-spacing:.02em; font-variant-numeric: tabular-nums; }
    .sub{ color:var(--muted); font-size:12px; }
    .card-actions{ display:flex; align-items:center; gap:6px; }
    .pin{ border:1px solid var(--border); background:transparent; color:var(--muted); padding:4px 8px; border-radius:8px; cursor:pointer; }
    .pin:hover{ color:var(--fg); border-color:var(--accent); }
    .pin[aria-pressed="true"]{ color:var(--accent); border-color:var(--accent); }
    .remove{
      border:1px solid var(--border); background:transparent; color:var(--muted);
      padding:4px 8px; border-radius:8px; cursor:pointer;
    }
    .remove:hover{ color:var(--fg); border-color:var(--accent); }

    /* ---------- Misc ---------- */
    .sr-only{ position:absolute; width:1px; height:1px; padding:0; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0; }

    @media (prefers-reduced-motion: reduce){
      *{ animation-duration:0.001ms !important; animation-iteration-count:1 !important; transition:none !important; }
    }
  </style>
</head>
<body>
  <main class="container">
    <header>
      <h1>Time</h1>
      <div class="controls">
        <button id="toggleFormat" aria-pressed="false" title="Toggle 12/24‑hour">24‑hour</button>
        <button id="resetCities" title="Restore default cities">Reset</button>
      </div>
    </header>

    <section class="hero" aria-labelledby="localLabel">
      <div id="localLabel" class="hero-label">Local time</div>
      <div id="localClock" class="bigtime" aria-live="off">--:--:--</div>
      <div class="meta">
        <span id="localZone">Zone: —</span>
        <span aria-hidden="true">•</span>
        <span id="nearby">Locating…</span>
        <span aria-hidden="true">•</span>
        <span id="dstBadge" class="badge">DST: —</span>
      </div>
      <div id="dstNext" class="countdown"></div>
    </section>

    <section class="map-card" aria-labelledby="mapLabel">
      <div class="map-head">
        <h2 id="mapLabel" class="map-title">Location map</h2>
        <p id="mapStatus" class="map-status">Waiting for location…</p>
      </div>
      <img id="mapImage" class="map-frame" alt="Map placeholder" loading="lazy" />
    </section>

    <section aria-labelledby="worldLabel">
      <h2 id="worldLabel" class="sr-only">World clocks</h2>
      <form id="addForm" class="adder" autocomplete="off">
        <label class="sr-only" for="tzInput">Add a time zone</label>
        <input id="tzInput" type="text" list="tzlist" placeholder="Add a city or IANA time zone (e.g., Europe/Paris)" />
        <datalist id="tzlist"></datalist>
        <button type="submit" class="btn">Add</button>
      </form>

      <div class="controls sort-controls" aria-label="Sort time zones">
        <button type="button" id="sortByName">Sort by name</button>
        <button type="button" id="sortByTime">Sort by current time</button>
      </div>

      <div id="grid" class="grid" aria-live="off"></div>
    </section>
  </main>

  <script>
  (function(){
    "use strict";

    /* --------- Config --------- */
    const DEFAULT_ZONES = [
      "UTC",
      "America/Chicago",      // Austin, Texas
      "Europe/Paris",         // Paris, France
      "Africa/Casablanca",    // Marrakech, Morocco
      "America/New_York"      // Gainesville, Florida
    ];
    const CUSTOM_NAMES = new Map([
      ["America/Chicago", "Austin, Texas"],
      ["Europe/Paris", "Paris, France"],
      ["Africa/Casablanca", "Marrakech, Morocco"],
      ["America/New_York", "Gainesville, Florida"],
    ]);
    const POPULAR_ZONES = [
      "UTC","America/New_York","America/Chicago","America/Denver","America/Los_Angeles","America/Phoenix",
      "America/Toronto","America/Mexico_City","America/Sao_Paulo","America/Anchorage","America/Halifax",
      "Europe/London","Europe/Paris","Europe/Berlin","Europe/Madrid","Europe/Rome","Europe/Moscow",
      "Africa/Casablanca","Africa/Cairo","Africa/Johannesburg",
      "Asia/Jerusalem","Asia/Dubai","Asia/Kolkata","Asia/Bangkok",
      "Asia/Singapore","Asia/Hong_Kong","Asia/Tokyo","Asia/Seoul",
      "Australia/Sydney","Pacific/Auckland"
    ];

    /* --------- State --------- */
    const STATE = {
      is24h: JSON.parse(localStorage.getItem("time.is24h") ?? "true"),
      zones: dedupe(JSON.parse(localStorage.getItem("time.zones") ?? "null") || DEFAULT_ZONES),
      localTZ: Intl.DateTimeFormat().resolvedOptions().timeZone || "UTC",
      mainTZ: null,
    };
    const MAP_STATE = { lat:null, lon:null, label:null };
    const FORMATTERS = new Map();      // key: `${tz}|${STATE.is24h}`
    const CARDS = new Map();           // tz -> {root,timeEl,subEl,titleEl,pinEl}

    /* --------- Helpers --------- */
    const $ = (sel, root=document) => root.querySelector(sel);
    const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));

    function dedupe(list){
      if (!Array.isArray(list)) list = DEFAULT_ZONES;
      const seen = new Set();
      const result = [];
      for (const tz of list){
        if (!tz || seen.has(tz)) continue;
        seen.add(tz); result.push(tz);
      }
      return result;
    }

    function saveZones(){ localStorage.setItem("time.zones", JSON.stringify([...STATE.zones])); }
    function saveFormat(){ localStorage.setItem("time.is24h", JSON.stringify(STATE.is24h)); }

    function safeFormatter(tz){
      const key = tz+"|"+(STATE.is24h?"24":"12");
      if (FORMATTERS.has(key)) return FORMATTERS.get(key);
      const fmt = new Intl.DateTimeFormat(navigator.language || "en-US", {
        hour: "2-digit", minute: "2-digit", second: "2-digit",
        hour12: !STATE.is24h, timeZone: tz
      });
      FORMATTERS.set(key, fmt);
      return fmt;
    }

    function friendlyNameFromTZ(tz){
      if (CUSTOM_NAMES.has(tz)) return CUSTOM_NAMES.get(tz);
      if (tz === "UTC") return "UTC";
      const part = tz.split("/").pop() || tz;
      return part.replace(/_/g," ");
    }

    function offsetLabel(tz, date){
      try{
        const parts = new Intl.DateTimeFormat("en", { timeZone: tz, timeZoneName:"shortOffset", hour:"2-digit" })
          .formatToParts(date);
        const tzn = parts.find(p=>p.type==="timeZoneName");
        return tzn ? tzn.value.replace("GMT","UTC") : "";
      }catch{ return ""; }
    }

    function validTimeZone(tz){
      try{ new Intl.DateTimeFormat(undefined, { timeZone: tz }); return true; }
      catch{ return false; }
    }

    function msToNextSecond(){
      const now = Date.now();
      return 1000 - (now % 1000);
    }

    function formatDateTime(dt, tz = STATE.mainTZ){
      // Short local date + time for labels (not the main clock)
      return new Intl.DateTimeFormat(navigator.language || "en-US", {
        year:"numeric", month:"short", day:"2-digit",
        hour:"2-digit", minute:"2-digit",
        hour12: !STATE.is24h, timeZone: tz
      }).format(dt);
    }

    function zoneTimeValue(tz, ref = new Date()){
      // Timestamp for comparison in a given time zone
      return new Date(ref.toLocaleString("en-US", { timeZone: tz })).getTime();
    }

    /* --------- Build UI --------- */
    const grid = $("#grid");
    const localClock = $("#localClock");
    const localZone = $("#localZone");
    const nearby = $("#nearby");
    const dstBadge = $("#dstBadge");
    const dstNext = $("#dstNext");
    const heroLabel = $("#localLabel");
    const mapImg = $("#mapImage");
    const mapStatus = $("#mapStatus");
    const toggleFormatBtn = $("#toggleFormat");
    const resetBtn = $("#resetCities");
    const addForm = $("#addForm");
    const tzInput = $("#tzInput");
    const tzlist = $("#tzlist");
    const sortByNameBtn = $("#sortByName");
    const sortByTimeBtn = $("#sortByTime");

    function reorderFromDOM(){
      const order = $$(".card", grid).map(c=>c.dataset.tz).filter(Boolean);
      STATE.zones = order;
      saveZones();
    }

    // Fill datalist once
    function populateDatalist(){
      const opts = new DocumentFragment();
      (window.Intl && Intl.supportedValuesOf ? Intl.supportedValuesOf("timeZone") : POPULAR_ZONES)
        .slice(0, 400) // cap to avoid huge lists on some browsers
        .forEach(tz=>{
          const opt = document.createElement("option");
          opt.value = tz;
          opt.label = friendlyNameFromTZ(tz);
          opts.appendChild(opt);
        });
      tzlist.appendChild(opts);
    }

    function makeCard(tz){
      if (CARDS.has(tz)) return;
      const card = document.createElement("article");
      card.className = "card";
      card.dataset.tz = tz;
      card.draggable = true;
      card.innerHTML = `
        <header>
          <h3 class="title">${friendlyNameFromTZ(tz)}</h3>
          <div class="card-actions">
            <button class="pin" title="Make ${tz} the main clock" aria-label="Make ${tz} the main clock" aria-pressed="false">☆</button>
            <button class="remove" title="Remove ${tz}" aria-label="Remove ${tz}">×</button>
          </div>
        </header>
        <div class="smalltime" aria-live="off">--:--:--</div>
        <div class="sub" data-sub>—</div>
      `;
      grid.appendChild(card);
      const timeEl = card.querySelector(".smalltime");
      const subEl = card.querySelector("[data-sub]");
      const titleEl = card.querySelector(".title");
      const pinEl = card.querySelector(".pin");

      card.addEventListener("dragstart", (e)=>{
        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.setData("text/plain", tz);
        card.classList.add("dragging");
      });
      card.addEventListener("dragend", ()=>{ card.classList.remove("dragging"); reorderFromDOM(); });
      card.addEventListener("dragover", (e)=>{
        e.preventDefault();
        const dragging = grid.querySelector(".card.dragging");
        if (!dragging || dragging === card) return;
        const rect = card.getBoundingClientRect();
        const before = (e.clientY - rect.top) < rect.height/2;
        grid.insertBefore(dragging, before ? card : card.nextSibling);
      });
      card.addEventListener("drop", (e)=>{ e.preventDefault(); reorderFromDOM(); });

      pinEl.addEventListener("click", ()=>{ setMainTZ(tz); }, {passive:true});

      card.querySelector(".remove").addEventListener("click", ()=>{
        STATE.zones = STATE.zones.filter(z=>z!==tz); saveZones();
        FORMATTERS.forEach((_,k)=>{ if (k.startsWith(tz+"|")) FORMATTERS.delete(k); });
        if (STATE.mainTZ === tz) setMainTZ(STATE.localTZ);
        CARDS.delete(tz); card.remove();
      }, {passive:true});

      CARDS.set(tz, {root:card, timeEl, subEl, titleEl, pinEl});
    }

    function rebuildGrid(){
      grid.innerHTML = "";
      CARDS.clear();
      STATE.zones.forEach(makeCard);
      refreshPinStates();
    }

    /* --------- Local info: zone + IP location --------- */
    let locationMessage = "Locating…";

    function renderNearby(){
      if (STATE.mainTZ === STATE.localTZ) nearby.textContent = locationMessage;
      else nearby.textContent = `Pinned: ${friendlyNameFromTZ(STATE.mainTZ)}`;
    }

    function renderMap(){
      if (!mapImg || !mapStatus) return;
      if (Number.isFinite(MAP_STATE.lat) && Number.isFinite(MAP_STATE.lon)){
        const lat = MAP_STATE.lat.toFixed(4);
        const lon = MAP_STATE.lon.toFixed(4);
        const label = MAP_STATE.label || locationMessage || "your approximate location";
        const marker = `${lat},${lon},lightblue1`;
        mapImg.src = `https://staticmap.openstreetmap.de/staticmap.php?center=${lat},${lon}&zoom=4&size=900x320&markers=${marker}`;
        mapImg.alt = `Map centered near ${label}`;
        mapStatus.textContent = `Showing an approximate map for ${label}`;
      }else{
        mapImg.removeAttribute("src");
        mapImg.alt = "Map placeholder";
        mapStatus.textContent = "Map unavailable without location access.";
      }
    }

    function setLocalLabels(){
      heroLabel.textContent = STATE.mainTZ === STATE.localTZ ? "Local time" : "Main time";
      localZone.textContent = "Zone: " + (STATE.mainTZ || "UTC");
      renderNearby();
    }

    async function tryIPLocation(){
      // Best‑effort with timeout and graceful fallback
      const ctrl = new AbortController();
      const t = setTimeout(()=>ctrl.abort(), 1000);
      try{
        const res = await fetch("https://ipapi.co/json/", {signal: ctrl.signal});
        clearTimeout(t);
        if (!res.ok) throw new Error("ipapi.co error");
        const data = await res.json();
        const city = data.city || null;
        const country = data.country_name || data.country || null;
        const lat = Number(data.latitude);
        const lon = Number(data.longitude);
        if (city && country){
          locationMessage = `You are near ${city}, ${country}`;
          MAP_STATE.label = `${city}, ${country}`;
        }else if (country){
          locationMessage = `You are in ${country}`;
          MAP_STATE.label = country;
        }else{
          locationMessage = "Location not available";
          MAP_STATE.label = null;
        }
        if (Number.isFinite(lat) && Number.isFinite(lon)){
          MAP_STATE.lat = lat;
          MAP_STATE.lon = lon;
        }
      }catch{
        locationMessage = "Location based on device time zone";
        MAP_STATE.lat = null; MAP_STATE.lon = null; MAP_STATE.label = null;
      }
      renderNearby();
      renderMap();
    }

    /* --------- DST: status + next change for the main clock --------- */
    function offsetMinutes(tz, date){
      try{
        const parts = new Intl.DateTimeFormat("en-US", { timeZone: tz, timeZoneName:"shortOffset", hour:"2-digit", minute:"2-digit", second:"2-digit" })
          .formatToParts(date);
        const tzn = parts.find(p=>p.type==="timeZoneName");
        if (!tzn) return null;
        const label = tzn.value.replace("GMT","UTC");
        if (label === "UTC") return 0;
        const match = label.match(/^UTC([+-])(\d{1,2})(?::?(\d{2}))?$/);
        if (!match) return null;
        const sign = match[1] === "-" ? -1 : 1;
        const hours = Number(match[2]);
        const mins = Number(match[3] || "0");
        return sign * (hours*60 + mins);
      }catch{ return null; }
    }

    function tzHasDST(tz, year){
      const jan = offsetMinutes(tz, new Date(Date.UTC(year,0,1,12,0,0,0)));
      const jul = offsetMinutes(tz, new Date(Date.UTC(year,6,1,12,0,0,0)));
      if (jan === null || jul === null) return false;
      return jan !== jul;
    }

    function tzDSTActive(tz, now){
      const y = now.getUTCFullYear();
      const jan = offsetMinutes(tz, new Date(Date.UTC(y,0,1,12,0,0,0)));
      const jul = offsetMinutes(tz, new Date(Date.UTC(y,6,1,12,0,0,0)));
      const cur = offsetMinutes(tz, now);
      if (jan === null || jul === null || cur === null) return false;
      const std = Math.max(jan, jul);
      return cur < std; // smaller offset -> DST
    }

    // Find the next DST change by scanning days, then binary search to minute
    function findNextDSTChange(tz, now = new Date()){
      const startOffset = offsetMinutes(tz, now);
      if (startOffset === null) return null;
      const y = now.getUTCFullYear();
      if (!tzHasDST(tz, y) && !tzHasDST(tz, y+1)) return null; // no DST here
      // scan up to ~370 days at noon UTC to find a day where offset differs
      for (let i=0; i<=370; i++){
        const d = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()+i, 12, 0, 0, 0));
        const off = offsetMinutes(tz, d);
        if (off === null) continue;
        if (off !== startOffset){
          // Transition inside [d-1, d]
          let lo = new Date(d.getTime() - 24*3600*1000);
          let hi = d;
          const baseOff = offsetMinutes(tz, lo);
          let found = hi;
          while ((hi - lo) > 60000){ // search to minute
            const mid = new Date((lo.getTime() + hi.getTime())/2);
            const offMid = offsetMinutes(tz, mid);
            if (offMid === baseOff){ lo = new Date(mid.getTime()+1); }
            else { found = mid; hi = mid; }
          }
          return found;
        }
      }
      return null;
    }

    function humanCountdown(ms){
      if (ms <= 0) return "now";
      const s = Math.floor(ms/1000);
      const d = Math.floor(s/86400);
      const h = Math.floor((s%86400)/3600);
      const m = Math.floor((s%3600)/60);
      return `${d}d ${h}h ${m}m`;
    }

    function updateDST(now){
      const tz = STATE.mainTZ || STATE.localTZ;
      const active = tzDSTActive(tz, now);
      dstBadge.textContent = "DST: " + (active ? "Active" : "Off");
      const next = findNextDSTChange(tz, now);
      if (!next){
        dstNext.textContent = "No DST changes in this region.";
        return;
      }
      const ms = next - now;
      dstNext.textContent = `Next DST change: ${formatDateTime(next, tz)} • ${humanCountdown(ms)}`;
    }

    /* --------- Ticking --------- */
    function tick(){
      const now = new Date();

      // Hero big clock
      localClock.textContent = safeFormatter(STATE.mainTZ).format(now);

      // World cards
      for (const [tz, obj] of CARDS){
        const fmt = safeFormatter(tz);
        const tstr = fmt.format(now);
        if (obj.timeEl.textContent !== tstr) obj.timeEl.textContent = tstr;

        // Update sub once per minute (reduce work)
        if (now.getSeconds() === 0){
          const off = offsetLabel(tz, now);
          obj.subEl.textContent = off ? `${off}` : "";
        }
      }

      // Hero DST badge each minute
      if (now.getSeconds() === 0) updateDST(now);

      // Align next tick to the next wall‑second
      setTimeout(tick, msToNextSecond());
    }

    /* --------- Events --------- */
    toggleFormatBtn.addEventListener("click", ()=>{
      STATE.is24h = !STATE.is24h; saveFormat();
      toggleFormatBtn.textContent = STATE.is24h ? "24‑hour" : "12‑hour";
      toggleFormatBtn.setAttribute("aria-pressed", String(!STATE.is24h));
      // clear formatters to rebuild with new hour cycle
      FORMATTERS.clear();
    });

    resetBtn.addEventListener("click", ()=>{
      STATE.zones = [...DEFAULT_ZONES];
      saveZones();
      rebuildGrid();
    });

    sortByNameBtn.addEventListener("click", ()=>{
      STATE.zones = [...STATE.zones].sort((a,b)=>friendlyNameFromTZ(a).localeCompare(friendlyNameFromTZ(b), undefined, {sensitivity:"base"}));
      saveZones();
      rebuildGrid();
    });

    sortByTimeBtn.addEventListener("click", ()=>{
      const now = new Date();
      STATE.zones = [...STATE.zones].sort((a,b)=>zoneTimeValue(a, now) - zoneTimeValue(b, now));
      saveZones();
      rebuildGrid();
    });

    addForm.addEventListener("submit", (e)=>{
      e.preventDefault();
      const val = tzInput.value.trim();
      if (!val){ return; }
      const tz = val;
      if (!validTimeZone(tz)){
        alert("That does not look like a valid IANA time zone.\nExample: Europe/Paris");
        return;
      }
      if (!STATE.zones.includes(tz)) STATE.zones = [...STATE.zones, tz];
      saveZones();
      makeCard(tz);
      tzInput.value = "";
    });

    function refreshPinStates(){
      for (const [tz, obj] of CARDS){
        const pinned = tz === STATE.mainTZ;
        obj.pinEl.setAttribute("aria-pressed", String(pinned));
        obj.pinEl.textContent = pinned ? "★" : "☆";
        obj.pinEl.title = pinned ? `${tz} is the main clock` : `Make ${tz} the main clock`;
      }
    }

    function saveMainTZ(){ localStorage.setItem("time.mainTZ", JSON.stringify(STATE.mainTZ)); }

    function setMainTZ(tz){
      if (!tz || !validTimeZone(tz)) tz = STATE.localTZ;
      STATE.mainTZ = tz;
      saveMainTZ();
      localClock.textContent = safeFormatter(STATE.mainTZ).format(new Date());
      setLocalLabels();
      refreshPinStates();
      updateDST(new Date());
    }

    /* --------- Init --------- */
    populateDatalist();
    STATE.mainTZ = JSON.parse(localStorage.getItem("time.mainTZ") ?? "null") || STATE.localTZ;
    if (!validTimeZone(STATE.mainTZ)) STATE.mainTZ = STATE.localTZ;

    setLocalLabels();
    rebuildGrid();
    refreshPinStates();
    tryIPLocation();

    // Pre-pin UTC if not present
    if (!STATE.zones.includes("UTC")){ STATE.zones = [...STATE.zones, "UTC"]; saveZones(); makeCard("UTC"); refreshPinStates(); }

    // First paint and timers
    updateDST(new Date());
    toggleFormatBtn.textContent = STATE.is24h ? "24‑hour" : "12‑hour";
    setTimeout(tick, msToNextSecond());
  })();
  </script>
</body>
</html>
