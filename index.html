<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="light dark" />
  <title>Time</title>
  <style>
    /* ---------- Base ---------- */
    :root{
      --bg:#0b0c10; --fg:#e9e9ef; --muted:#a7a7b3; --card:#15161d; --border:#242633; --accent:#6ea8fe;
      --shadow: 0 1px 2px rgba(0,0,0,.15), 0 8px 24px rgba(0,0,0,.18);
    }
    @media (prefers-color-scheme: light){
      :root{ --bg:#f7f7fb; --fg:#14151a; --muted:#55586a; --card:#ffffff; --border:#e8e9ee; --accent:#2b59ff; --shadow: 0 1px 2px rgba(0,0,0,.06), 0 8px 24px rgba(0,0,0,.08); }
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0; background:var(--bg); color:var(--fg);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans", Ubuntu, Cantarell, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
      -webkit-font-smoothing:antialiased; line-height:1.35;
    }
    .container{ max-width: 1100px; margin: 0 auto; padding: 20px; }

    /* ---------- Header / Controls ---------- */
    header{
      display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom: 12px;
    }
    h1{ font-size: clamp(22px, 2.4vw, 28px); margin:0; letter-spacing:.2px; }
    .controls{ display:flex; gap:8px; flex-wrap:wrap; }
    .sort-controls{ justify-content:flex-start; margin: 0 0 10px; }
    button, .btn{
      appearance:none; border:1px solid var(--border); background:var(--card); color:var(--fg);
      padding:8px 10px; border-radius:9px; cursor:pointer; font-weight:600; box-shadow: var(--shadow);
    }
    button:hover{ border-color:var(--accent); }
    button:focus-visible{ outline:2px solid var(--accent); outline-offset:2px; }

    /* ---------- Hero Clock ---------- */
    .hero{
      border:1px solid var(--border); background:var(--card); border-radius:14px; padding:22px; box-shadow: var(--shadow);
      display:grid; gap:10px; justify-items:center; margin-bottom: 18px;
    }
    .hero-label{ font-size:14px; color:var(--muted); }
    .bigtime{
      font-size: clamp(40px, 9vw, 96px);
      line-height:1; font-weight:800; letter-spacing: .02em;
      font-variant-numeric: tabular-nums;
      text-align:center;
    }
    .meta{ color:var(--muted); font-size: 14px; display:flex; gap:10px; flex-wrap:wrap; justify-content:center; }
    .badge{
      display:inline-flex; align-items:center; gap:6px;
      padding:4px 8px; border-radius:999px; border:1px solid var(--border); background:transparent; color:var(--fg);
      font-size:12px; font-weight:600;
    }
    .countdown{ font-size:13px; color:var(--muted); }

    /* ---------- Map ---------- */
    .map-card{
      border:1px solid var(--border); background:var(--card); border-radius:14px; box-shadow: var(--shadow);
      padding:16px; display:grid; gap:10px; margin: 0 0 18px; overflow:hidden;
    }
    .map-head{ display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; }
    .map-title{ margin:0; font-size:18px; }
    .map-status{ color:var(--muted); font-size:14px; margin:0; }
    .tz-map{
      position:relative; border-radius:12px; border:1px solid var(--border);
      min-height:240px; overflow:hidden; background:radial-gradient(circle at 30% 30%, rgba(110,168,254,.08), transparent 45%),
        radial-gradient(circle at 70% 70%, rgba(110,168,254,.12), transparent 50%),
        repeating-linear-gradient(90deg, color-mix(in srgb, var(--border) 70%, transparent) 0 32px, transparent 32px 64px),
        linear-gradient(90deg, rgba(110,168,254,.12), rgba(110,168,254,.04) 20%, rgba(110,168,254,.12) 40%, rgba(110,168,254,.04) 60%, rgba(110,168,254,.12) 80%, rgba(110,168,254,.04));
      isolation:isolate;
    }
    .tz-stripes{ position:absolute; inset:0; pointer-events:none; background: repeating-linear-gradient(90deg, transparent 0 44px, rgba(255,255,255,.04) 44px 48px); mix-blend-mode:screen; opacity:.6; }
    .tz-globe{ position:absolute; inset:0; width:100%; height:100%; object-fit:cover; opacity:.32; filter: drop-shadow(0 8px 16px rgba(0,0,0,.24)); }
    .pin-layer{ position:absolute; inset:0; padding:22px 18px 14px; display:grid; align-content:end; }
    .map-pin{
      position:absolute; transform:translate(-50%,-50%); min-width:110px; max-width:160px; pointer-events:auto;
      background:rgba(0,0,0,.24); backdrop-filter:blur(6px); border:1px solid var(--border); border-radius:10px; padding:7px 9px;
      color:var(--fg); box-shadow: var(--shadow); text-align:center; font-size:12px;
    }
    .map-pin[data-main="true"]{ border-color:var(--accent); box-shadow:0 4px 18px rgba(110,168,254,.35), var(--shadow); }
    .map-pin strong{ display:block; font-size:13px; margin-bottom:4px; }
    .map-pin-time{ color:var(--muted); font-variant-numeric: tabular-nums; }
    .map-pin-dot{ position:absolute; inset:auto auto -10px 50%; transform:translateX(-50%); width:12px; height:12px; border-radius:50%; background:var(--accent); box-shadow:0 0 0 4px color-mix(in srgb, var(--accent) 35%, transparent); }
    .map-pin[data-main="true"] .map-pin-dot{ background:var(--accent); box-shadow:0 0 0 5px color-mix(in srgb, var(--accent) 45%, transparent); }
    .map-pin[data-level="1"]{ opacity:.9; }
    .map-pin[data-level="2"]{ opacity:.85; }
    .map-pin[data-level="3"]{ opacity:.8; }
    .map-pin[data-level="4"]{ opacity:.75; }
    .map-pin[data-level="5"]{ opacity:.7; }

    /* ---------- Add City ---------- */
    .adder{
      display:flex; gap:8px; align-items:center; justify-content:center; flex-wrap:wrap; margin: 6px 0 14px;
    }
    input[type="text"]{
      background:var(--card); color:var(--fg); border:1px solid var(--border);
      padding:9px 10px; border-radius:9px; min-width:260px;
    }
    input::placeholder{ color:var(--muted); }
    input:focus-visible{ outline:2px solid var(--accent); outline-offset:2px; }

    /* ---------- Grid ---------- */
    .grid{
      display:grid; gap:12px;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }
    .card{
      border:1px solid var(--border); background:var(--card); border-radius:12px; padding:12px 12px 14px; box-shadow: var(--shadow);
      display:grid; gap:6px;
    }
    .card.dragging{ opacity:.75; border-style:dashed; }
    .card header{ display:flex; align-items:center; justify-content:space-between; gap: 8px; }
    .title{ font-size:16px; margin:0; }
    .smalltime{ font-size:28px; font-weight:700; letter-spacing:.02em; font-variant-numeric: tabular-nums; }
    .sub{ color:var(--muted); font-size:12px; }
    .card-actions{ display:flex; align-items:center; gap:6px; }
    .pin{ border:1px solid var(--border); background:transparent; color:var(--muted); padding:4px 8px; border-radius:8px; cursor:pointer; }
    .pin:hover{ color:var(--fg); border-color:var(--accent); }
    .pin[aria-pressed="true"]{ color:var(--accent); border-color:var(--accent); }
    .remove{
      border:1px solid var(--border); background:transparent; color:var(--muted);
      padding:4px 8px; border-radius:8px; cursor:pointer;
    }
    .remove:hover{ color:var(--fg); border-color:var(--accent); }

    /* ---------- Misc ---------- */
    .sr-only{ position:absolute; width:1px; height:1px; padding:0; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0; }

    @media (prefers-reduced-motion: reduce){
      *{ animation-duration:0.001ms !important; animation-iteration-count:1 !important; transition:none !important; }
    }
  </style>
</head>
<body>
  <main class="container">
    <header>
      <h1>Time</h1>
      <div class="controls">
        <button id="toggleFormat" aria-pressed="false" title="Toggle 12/24‑hour">24‑hour</button>
        <button id="resetCities" title="Restore default cities">Reset</button>
      </div>
    </header>

    <section class="hero" aria-labelledby="localLabel">
      <div id="localLabel" class="hero-label">Local time</div>
      <div id="localClock" class="bigtime" aria-live="off">--:--:--</div>
      <div class="meta">
        <span id="localZone">Zone: —</span>
        <span aria-hidden="true">•</span>
        <span id="nearby">Locating…</span>
        <span aria-hidden="true">•</span>
        <span id="dstBadge" class="badge">DST: —</span>
      </div>
      <div id="dstNext" class="countdown"></div>
    </section>

    <section class="map-card" aria-labelledby="mapLabel">
      <div class="map-head">
        <h2 id="mapLabel" class="map-title">Time zone map</h2>
        <p id="mapStatus" class="map-status">Pins follow your saved clocks by UTC offset.</p>
      </div>
      <div id="tzMap" class="tz-map" role="img" aria-label="Time zone stripes with pins for your clocks">
        <div class="tz-stripes" aria-hidden="true"></div>
        <svg class="tz-globe" viewBox="0 0 800 360" aria-hidden="true" preserveAspectRatio="xMidYMid slice">
          <defs>
            <linearGradient id="glow" x1="0%" x2="100%" y1="0%" y2="0%">
              <stop offset="0%" stop-color="var(--accent)" stop-opacity=".45" />
              <stop offset="50%" stop-color="var(--accent)" stop-opacity=".25" />
              <stop offset="100%" stop-color="var(--accent)" stop-opacity=".4" />
            </linearGradient>
          </defs>
          <rect x="0" y="0" width="800" height="360" fill="url(#glow)" opacity=".18" />
          <path fill="var(--fg)" opacity=".22" d="M75,182c40-52,120-74,200-50c34,10,70,32,102,26c38-7,28-44,64-48c46-5,116,44,148,74c26,24,69,67,83,94c4,7-4,14-11,10c-57-34-114-78-172-72c-52,5-101,42-151,44c-66,3-142-43-193-70C99,180,65,195,75,182z" />
          <path fill="var(--fg)" opacity=".18" d="M94,110c24-18,60-34,112-26c62,10,86,70,140,80c31,6,80-20,108-34c18-10,23,14,45,20c28,8,53-28,78-18c38,16,70,92,70,128c0,6-5,9-10,6c-32-21-67-54-106-56c-66-2-134,54-198,50c-44-3-114-61-150-86C102,154,70,128,94,110z" />
          <circle cx="420" cy="96" r="38" fill="var(--fg)" opacity=".12" />
        </svg>
        <div id="pinLayer" class="pin-layer" aria-live="polite"></div>
      </div>
    </section>

    <section aria-labelledby="worldLabel">
      <h2 id="worldLabel" class="sr-only">World clocks</h2>
      <form id="addForm" class="adder" autocomplete="off">
        <label class="sr-only" for="tzInput">Add a time zone</label>
        <input id="tzInput" type="text" list="tzlist" placeholder="Add a city or IANA time zone (e.g., Europe/Paris)" />
        <datalist id="tzlist"></datalist>
        <button type="submit" class="btn">Add</button>
      </form>

      <div class="controls sort-controls" aria-label="Sort time zones">
        <button type="button" id="sortByName">Sort by name</button>
        <button type="button" id="sortByTime">Sort by current time</button>
      </div>

      <div id="grid" class="grid" aria-live="off"></div>
    </section>
  </main>

  <script>
  (function(){
    "use strict";

    /* --------- Config --------- */
    const DEFAULT_ZONES = [
      "UTC",
      "America/Chicago",      // Austin, Texas
      "Europe/Paris",         // Paris, France
      "Africa/Casablanca",    // Marrakech, Morocco
      "America/New_York"      // Gainesville, Florida
    ];
    const CUSTOM_NAMES = new Map([
      ["America/Chicago", "Austin, Texas"],
      ["Europe/Paris", "Paris, France"],
      ["Africa/Casablanca", "Marrakech, Morocco"],
      ["America/New_York", "Gainesville, Florida"],
    ]);
    const POPULAR_ZONES = [
      "UTC","America/New_York","America/Chicago","America/Denver","America/Los_Angeles","America/Phoenix",
      "America/Toronto","America/Mexico_City","America/Sao_Paulo","America/Anchorage","America/Halifax",
      "Europe/London","Europe/Paris","Europe/Berlin","Europe/Madrid","Europe/Rome","Europe/Moscow",
      "Africa/Casablanca","Africa/Cairo","Africa/Johannesburg",
      "Asia/Jerusalem","Asia/Dubai","Asia/Kolkata","Asia/Bangkok",
      "Asia/Singapore","Asia/Hong_Kong","Asia/Tokyo","Asia/Seoul",
      "Australia/Sydney","Pacific/Auckland"
    ];
    const TZ_RANGE = { min: -12, max: 14 };

    /* --------- State --------- */
    const STATE = {
      is24h: JSON.parse(localStorage.getItem("time.is24h") ?? "true"),
      zones: dedupe(JSON.parse(localStorage.getItem("time.zones") ?? "null") || DEFAULT_ZONES),
      localTZ: Intl.DateTimeFormat().resolvedOptions().timeZone || "UTC",
      mainTZ: null,
    };
    const FORMATTERS = new Map();      // key: `${tz}|${STATE.is24h}`
    const CARDS = new Map();           // tz -> {root,timeEl,subEl,titleEl,pinEl}

    /* --------- Helpers --------- */
    const $ = (sel, root=document) => root.querySelector(sel);
    const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));

    function dedupe(list){
      if (!Array.isArray(list)) list = DEFAULT_ZONES;
      const seen = new Set();
      const result = [];
      for (const tz of list){
        if (!tz || seen.has(tz)) continue;
        seen.add(tz); result.push(tz);
      }
      return result;
    }

    const clamp = (val, min, max) => Math.min(Math.max(val, min), max);

    function saveZones(){ localStorage.setItem("time.zones", JSON.stringify([...STATE.zones])); }
    function saveFormat(){ localStorage.setItem("time.is24h", JSON.stringify(STATE.is24h)); }

    function safeFormatter(tz){
      const key = tz+"|"+(STATE.is24h?"24":"12");
      if (FORMATTERS.has(key)) return FORMATTERS.get(key);
      const fmt = new Intl.DateTimeFormat(navigator.language || "en-US", {
        hour: "2-digit", minute: "2-digit", second: "2-digit",
        hour12: !STATE.is24h, timeZone: tz
      });
      FORMATTERS.set(key, fmt);
      return fmt;
    }

    function friendlyNameFromTZ(tz){
      if (CUSTOM_NAMES.has(tz)) return CUSTOM_NAMES.get(tz);
      if (tz === "UTC") return "UTC";
      const part = tz.split("/").pop() || tz;
      return part.replace(/_/g," ");
    }

    function offsetLabel(tz, date){
      try{
        const parts = new Intl.DateTimeFormat("en", { timeZone: tz, timeZoneName:"shortOffset", hour:"2-digit" })
          .formatToParts(date);
        const tzn = parts.find(p=>p.type==="timeZoneName");
        return tzn ? tzn.value.replace("GMT","UTC") : "";
      }catch{ return ""; }
    }

    function validTimeZone(tz){
      try{ new Intl.DateTimeFormat(undefined, { timeZone: tz }); return true; }
      catch{ return false; }
    }

    function msToNextSecond(){
      const now = Date.now();
      return 1000 - (now % 1000);
    }

    function formatDateTime(dt, tz = STATE.mainTZ){
      // Short local date + time for labels (not the main clock)
      return new Intl.DateTimeFormat(navigator.language || "en-US", {
        year:"numeric", month:"short", day:"2-digit",
        hour:"2-digit", minute:"2-digit",
        hour12: !STATE.is24h, timeZone: tz
      }).format(dt);
    }

    function zoneTimeValue(tz, ref = new Date()){
      // Timestamp for comparison in a given time zone
      return new Date(ref.toLocaleString("en-US", { timeZone: tz })).getTime();
    }

    /* --------- Build UI --------- */
    const grid = $("#grid");
    const localClock = $("#localClock");
    const localZone = $("#localZone");
    const nearby = $("#nearby");
    const dstBadge = $("#dstBadge");
    const dstNext = $("#dstNext");
    const heroLabel = $("#localLabel");
    const mapStatus = $("#mapStatus");
    const pinLayer = $("#pinLayer");
    const toggleFormatBtn = $("#toggleFormat");
    const resetBtn = $("#resetCities");
    const addForm = $("#addForm");
    const tzInput = $("#tzInput");
    const tzlist = $("#tzlist");
    const sortByNameBtn = $("#sortByName");
    const sortByTimeBtn = $("#sortByTime");

    function reorderFromDOM(){
      const order = $$(".card", grid).map(c=>c.dataset.tz).filter(Boolean);
      STATE.zones = order;
      saveZones();
      renderMapPins(new Date());
    }

    // Fill datalist once
    function populateDatalist(){
      const opts = new DocumentFragment();
      (window.Intl && Intl.supportedValuesOf ? Intl.supportedValuesOf("timeZone") : POPULAR_ZONES)
        .slice(0, 400) // cap to avoid huge lists on some browsers
        .forEach(tz=>{
          const opt = document.createElement("option");
          opt.value = tz;
          opt.label = friendlyNameFromTZ(tz);
          opts.appendChild(opt);
        });
      tzlist.appendChild(opts);
    }

    function makeCard(tz){
      if (CARDS.has(tz)) return;
      const card = document.createElement("article");
      card.className = "card";
      card.dataset.tz = tz;
      card.draggable = true;
      card.innerHTML = `
        <header>
          <h3 class="title">${friendlyNameFromTZ(tz)}</h3>
          <div class="card-actions">
            <button class="pin" title="Make ${tz} the main clock" aria-label="Make ${tz} the main clock" aria-pressed="false">☆</button>
            <button class="remove" title="Remove ${tz}" aria-label="Remove ${tz}">×</button>
          </div>
        </header>
        <div class="smalltime" aria-live="off">--:--:--</div>
        <div class="sub" data-sub>—</div>
      `;
      grid.appendChild(card);
      const timeEl = card.querySelector(".smalltime");
      const subEl = card.querySelector("[data-sub]");
      const titleEl = card.querySelector(".title");
      const pinEl = card.querySelector(".pin");

      card.addEventListener("dragstart", (e)=>{
        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.setData("text/plain", tz);
        card.classList.add("dragging");
      });
      card.addEventListener("dragend", ()=>{ card.classList.remove("dragging"); reorderFromDOM(); });
      card.addEventListener("dragover", (e)=>{
        e.preventDefault();
        const dragging = grid.querySelector(".card.dragging");
        if (!dragging || dragging === card) return;
        const rect = card.getBoundingClientRect();
        const before = (e.clientY - rect.top) < rect.height/2;
        grid.insertBefore(dragging, before ? card : card.nextSibling);
      });
      card.addEventListener("drop", (e)=>{ e.preventDefault(); reorderFromDOM(); });

      pinEl.addEventListener("click", ()=>{ setMainTZ(tz); }, {passive:true});

      card.querySelector(".remove").addEventListener("click", ()=>{
        STATE.zones = STATE.zones.filter(z=>z!==tz); saveZones();
        FORMATTERS.forEach((_,k)=>{ if (k.startsWith(tz+"|")) FORMATTERS.delete(k); });
        if (STATE.mainTZ === tz) setMainTZ(STATE.localTZ);
        CARDS.delete(tz); card.remove();
        renderMapPins(new Date());
      }, {passive:true});

      CARDS.set(tz, {root:card, timeEl, subEl, titleEl, pinEl});
    }

    function rebuildGrid(){
      grid.innerHTML = "";
      CARDS.clear();
      STATE.zones.forEach(makeCard);
      refreshPinStates();
      renderMapPins(new Date());
    }

    /* --------- Local info: zone + IP location --------- */
    let locationMessage = "Locating…";

    function renderNearby(){
      if (STATE.mainTZ === STATE.localTZ) nearby.textContent = locationMessage;
      else nearby.textContent = `Pinned: ${friendlyNameFromTZ(STATE.mainTZ)}`;
    }

    function hoursFromOffset(tz, date){
      const mins = offsetMinutes(tz, date);
      return Number.isFinite(mins) ? mins / 60 : null;
    }

    function percentFromOffset(hours){
      const clamped = clamp(hours, TZ_RANGE.min, TZ_RANGE.max);
      return ((clamped - TZ_RANGE.min) / (TZ_RANGE.max - TZ_RANGE.min)) * 100;
    }

    function renderMapPins(now = new Date()){
      if (!pinLayer || !mapStatus) return;
      pinLayer.innerHTML = "";
      const pins = STATE.zones.map(tz=>{
        const hours = hoursFromOffset(tz, now);
        if (hours === null) return null;
        return { tz, hours, label: friendlyNameFromTZ(tz), offset: offsetLabel(tz, now) };
      }).filter(Boolean);

      if (!pins.length){
        mapStatus.textContent = "Add a city to see pins on the map.";
        return;
      }

      pins.sort((a,b)=>a.hours - b.hours);
      const bucketCounts = new Map();
      const frag = document.createDocumentFragment();

      for (const pinData of pins){
        const pct = percentFromOffset(pinData.hours);
        const bucket = Math.round(pct);
        const used = bucketCounts.get(bucket) || 0;
        bucketCounts.set(bucket, used + 1);
        const direction = used % 2 === 0 ? -1 : 1;
        const steps = Math.floor(used / 2) + 1;
        const top = clamp(58 + direction * steps * 10, 18, 86);
        const utcLabel = pinData.offset || `UTC${pinData.hours >= 0 ? "+" : ""}${pinData.hours.toFixed(1)}`;
        const el = document.createElement("div");
        el.className = "map-pin";
        el.dataset.level = String(Math.min(5, used + 1));
        el.dataset.main = pinData.tz === STATE.mainTZ;
        el.style.left = `${pct}%`;
        el.style.top = `${top}%`;
        const timeStr = safeFormatter(pinData.tz).format(now);
        el.innerHTML = `
          <strong>${pinData.label}</strong>
          <div class="map-pin-time">${timeStr} • ${utcLabel}</div>
          <span class="map-pin-dot" aria-hidden="true"></span>
        `;
        el.setAttribute("aria-label", `${pinData.label} is ${utcLabel}; current time ${timeStr}`);
        frag.appendChild(el);
      }

      pinLayer.appendChild(frag);
      const pinnedName = friendlyNameFromTZ(STATE.mainTZ || STATE.localTZ);
      mapStatus.textContent = `Pins follow each clock's current UTC offset — ${pins.length} shown (★ ${pinnedName}).`;
    }

    function setLocalLabels(){
      heroLabel.textContent = STATE.mainTZ === STATE.localTZ ? "Local time" : "Main time";
      localZone.textContent = "Zone: " + (STATE.mainTZ || "UTC");
      renderNearby();
    }

    async function tryIPLocation(){
      // Best‑effort with timeout and graceful fallback
      const ctrl = new AbortController();
      const t = setTimeout(()=>ctrl.abort(), 1000);
      try{
        const res = await fetch("https://ipapi.co/json/", {signal: ctrl.signal});
        clearTimeout(t);
        if (!res.ok) throw new Error("ipapi.co error");
        const data = await res.json();
        const city = data.city || null;
        const country = data.country_name || data.country || null;
        if (city && country){
          locationMessage = `You are near ${city}, ${country}`;
        }else if (country){
          locationMessage = `You are in ${country}`;
        }else{
          locationMessage = "Location not available";
        }
      }catch{
        locationMessage = "Location based on device time zone";
      }
      renderNearby();
    }

    /* --------- DST: status + next change for the main clock --------- */
    function offsetMinutes(tz, date){
      try{
        const parts = new Intl.DateTimeFormat("en-US", { timeZone: tz, timeZoneName:"shortOffset", hour:"2-digit", minute:"2-digit", second:"2-digit" })
          .formatToParts(date);
        const tzn = parts.find(p=>p.type==="timeZoneName");
        if (!tzn) return null;
        const label = tzn.value.replace("GMT","UTC");
        if (label === "UTC") return 0;
        const match = label.match(/^UTC([+-])(\d{1,2})(?::?(\d{2}))?$/);
        if (!match) return null;
        const sign = match[1] === "-" ? -1 : 1;
        const hours = Number(match[2]);
        const mins = Number(match[3] || "0");
        return sign * (hours*60 + mins);
      }catch{ return null; }
    }

    function tzHasDST(tz, year){
      const jan = offsetMinutes(tz, new Date(Date.UTC(year,0,1,12,0,0,0)));
      const jul = offsetMinutes(tz, new Date(Date.UTC(year,6,1,12,0,0,0)));
      if (jan === null || jul === null) return false;
      return jan !== jul;
    }

    function tzDSTActive(tz, now){
      const y = now.getUTCFullYear();
      const jan = offsetMinutes(tz, new Date(Date.UTC(y,0,1,12,0,0,0)));
      const jul = offsetMinutes(tz, new Date(Date.UTC(y,6,1,12,0,0,0)));
      const cur = offsetMinutes(tz, now);
      if (jan === null || jul === null || cur === null) return false;
      const std = Math.max(jan, jul);
      return cur < std; // smaller offset -> DST
    }

    // Find the next DST change by scanning days, then binary search to minute
    function findNextDSTChange(tz, now = new Date()){
      const startOffset = offsetMinutes(tz, now);
      if (startOffset === null) return null;
      const y = now.getUTCFullYear();
      if (!tzHasDST(tz, y) && !tzHasDST(tz, y+1)) return null; // no DST here
      // scan up to ~370 days at noon UTC to find a day where offset differs
      for (let i=0; i<=370; i++){
        const d = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()+i, 12, 0, 0, 0));
        const off = offsetMinutes(tz, d);
        if (off === null) continue;
        if (off !== startOffset){
          // Transition inside [d-1, d]
          let lo = new Date(d.getTime() - 24*3600*1000);
          let hi = d;
          const baseOff = offsetMinutes(tz, lo);
          let found = hi;
          while ((hi - lo) > 60000){ // search to minute
            const mid = new Date((lo.getTime() + hi.getTime())/2);
            const offMid = offsetMinutes(tz, mid);
            if (offMid === baseOff){ lo = new Date(mid.getTime()+1); }
            else { found = mid; hi = mid; }
          }
          return found;
        }
      }
      return null;
    }

    function humanCountdown(ms){
      if (ms <= 0) return "now";
      const s = Math.floor(ms/1000);
      const d = Math.floor(s/86400);
      const h = Math.floor((s%86400)/3600);
      const m = Math.floor((s%3600)/60);
      return `${d}d ${h}h ${m}m`;
    }

    function updateDST(now){
      const tz = STATE.mainTZ || STATE.localTZ;
      const active = tzDSTActive(tz, now);
      dstBadge.textContent = "DST: " + (active ? "Active" : "Off");
      const next = findNextDSTChange(tz, now);
      if (!next){
        dstNext.textContent = "No DST changes in this region.";
        return;
      }
      const ms = next - now;
      dstNext.textContent = `Next DST change: ${formatDateTime(next, tz)} • ${humanCountdown(ms)}`;
    }

    /* --------- Ticking --------- */
    function tick(){
      const now = new Date();

      // Hero big clock
      localClock.textContent = safeFormatter(STATE.mainTZ).format(now);

      // World cards
      for (const [tz, obj] of CARDS){
        const fmt = safeFormatter(tz);
        const tstr = fmt.format(now);
        if (obj.timeEl.textContent !== tstr) obj.timeEl.textContent = tstr;

        // Update sub once per minute (reduce work)
        if (now.getSeconds() === 0){
          const off = offsetLabel(tz, now);
          obj.subEl.textContent = off ? `${off}` : "";
        }
      }

      // Hero DST badge each minute
      if (now.getSeconds() === 0){
        updateDST(now);
        renderMapPins(now);
      }

      // Align next tick to the next wall‑second
      setTimeout(tick, msToNextSecond());
    }

    /* --------- Events --------- */
    toggleFormatBtn.addEventListener("click", ()=>{
      STATE.is24h = !STATE.is24h; saveFormat();
      toggleFormatBtn.textContent = STATE.is24h ? "24‑hour" : "12‑hour";
      toggleFormatBtn.setAttribute("aria-pressed", String(!STATE.is24h));
      // clear formatters to rebuild with new hour cycle
      FORMATTERS.clear();
      renderMapPins(new Date());
    });

    resetBtn.addEventListener("click", ()=>{
      STATE.zones = [...DEFAULT_ZONES];
      saveZones();
      rebuildGrid();
    });

    sortByNameBtn.addEventListener("click", ()=>{
      STATE.zones = [...STATE.zones].sort((a,b)=>friendlyNameFromTZ(a).localeCompare(friendlyNameFromTZ(b), undefined, {sensitivity:"base"}));
      saveZones();
      rebuildGrid();
    });

    sortByTimeBtn.addEventListener("click", ()=>{
      const now = new Date();
      STATE.zones = [...STATE.zones].sort((a,b)=>zoneTimeValue(a, now) - zoneTimeValue(b, now));
      saveZones();
      rebuildGrid();
    });

    addForm.addEventListener("submit", (e)=>{
      e.preventDefault();
      const val = tzInput.value.trim();
      if (!val){ return; }
      const tz = val;
      if (!validTimeZone(tz)){
        alert("That does not look like a valid IANA time zone.\nExample: Europe/Paris");
        return;
      }
      if (!STATE.zones.includes(tz)) STATE.zones = [...STATE.zones, tz];
      saveZones();
      makeCard(tz);
      renderMapPins(new Date());
      tzInput.value = "";
    });

    function refreshPinStates(){
      for (const [tz, obj] of CARDS){
        const pinned = tz === STATE.mainTZ;
        obj.pinEl.setAttribute("aria-pressed", String(pinned));
        obj.pinEl.textContent = pinned ? "★" : "☆";
        obj.pinEl.title = pinned ? `${tz} is the main clock` : `Make ${tz} the main clock`;
      }
    }

    function saveMainTZ(){ localStorage.setItem("time.mainTZ", JSON.stringify(STATE.mainTZ)); }

    function setMainTZ(tz){
      if (!tz || !validTimeZone(tz)) tz = STATE.localTZ;
      STATE.mainTZ = tz;
      saveMainTZ();
      localClock.textContent = safeFormatter(STATE.mainTZ).format(new Date());
      setLocalLabels();
      refreshPinStates();
      updateDST(new Date());
      renderMapPins(new Date());
    }

    /* --------- Init --------- */
    populateDatalist();
    STATE.mainTZ = JSON.parse(localStorage.getItem("time.mainTZ") ?? "null") || STATE.localTZ;
    if (!validTimeZone(STATE.mainTZ)) STATE.mainTZ = STATE.localTZ;

    setLocalLabels();
    rebuildGrid();
    refreshPinStates();
    tryIPLocation();

    // Pre-pin UTC if not present
    if (!STATE.zones.includes("UTC")){ STATE.zones = [...STATE.zones, "UTC"]; saveZones(); makeCard("UTC"); refreshPinStates(); }

    // First paint and timers
    updateDST(new Date());
    toggleFormatBtn.textContent = STATE.is24h ? "24‑hour" : "12‑hour";
    setTimeout(tick, msToNextSecond());
  })();
  </script>
</body>
</html>
